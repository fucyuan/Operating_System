# 非连续内存分配：页表与TLB

## 1. 背景：分页机制与页表的作用
分页是操作系统中非连续内存分配的核心方法，通过将逻辑地址空间和物理地址空间划分为固定大小的页面（Page），实现灵活的内存管理。**页表（Page Table）**是分页机制的关键数据结构，负责将程序的逻辑地址映射到物理地址。页表存储在内存中，由操作系统维护，通常需要硬件支持（如内存管理单元MMU）来加速地址转换。

然而，页表机制在实现地址转换时会带来**空间开销**（页表占用内存）和**时间开销**（查询页表需要时间）。为了优化这些问题，操作系统引入了**转换旁路缓冲（TLB，Translation Lookaside Buffer）**和**间接页表**等技术。

本笔记详细讲解页表的结构、功能、实现方式，以及TLB的作用，并通过例子帮助初学者理解。

## 2. 页表的结构与功能
页表是连接**逻辑地址空间**和**物理地址空间**的桥梁，每个进程拥有一个独立的页表，存储页面到物理帧的映射关系。

### 2.1 页表的结构
页表是一个数组，索引为**页号（Page Number）**，每个表项包含以下信息：
- **物理帧号（Frame Number）**：逻辑页面映射到的物理内存帧的起始地址。
- **有效位（Valid Bit）**：表示页面是否在物理内存中（1表示在内存，0表示在磁盘）。
- **访问权限**：如读、写、执行权限，用于内存保护。
- **脏位（Dirty Bit）**（可选）：表示页面是否被修改，用于换出时决定是否写回磁盘。
- **引用位（Reference Bit）**（可选）：记录页面是否被访问，用于页面替换算法。

**例子**：
假设页面大小为4KB（4096字节），页表如下：

| 页号 | 物理帧号 | 有效位 | 权限   |
|------|----------|--------|--------|
| 0    | 10       | 1      | 读写   |
| 1    | 15       | 1      | 只读   |
| 2    | -        | 0      | -      |
| 3    | 20       | 1      | 读写   |

- 页号`1`映射到物理帧`15`，有效且只读。
- 页号`2`无效，可能在磁盘上，访问会触发缺页中断。

### 2.2 页表的功能
- **地址转换**：将逻辑地址（页号，偏移量）转换为物理地址（帧号，偏移量）。
- **内存保护**：通过权限位防止非法访问。
- **支持虚拟内存**：通过有效位支持页面换入换出，允许逻辑地址空间大于物理内存。

### 2.3 逻辑地址到物理地址的转换
逻辑地址由**页号**和**页内偏移量**组成，转换过程如下：
1. 根据页号查找页表，获取物理帧号和有效位。
2. 检查有效位：
   - 若为1，页面在内存中，继续转换。
   - 若为0，触发**缺页中断（Page Fault）**，操作系统从磁盘加载页面。
3. 计算物理地址：物理地址 = 物理帧号 × 页面大小 + 偏移量。

**例子**：
- 逻辑地址：`5000`（十六进制`0x1388`），页面大小4KB（4096字节）。
- 页号 = `5000 ÷ 4096 = 1`，偏移量 = `5000 % 4096 = 904`。
- 页表：页号`1`映射到帧`15`，有效。
- 物理帧起始地址 = `15 × 4096 = 61440`。
- 物理地址 = `61440 + 904 = 62344`。

## 3. 页表机制的挑战
页表虽然功能强大，但存在以下问题：
- **空间开销**：页表可能占用大量内存。例如，32位系统，页面大小4KB，逻辑地址空间为4GB（2^32字节），需要2^20（约100万个）页面，页表每项4字节，总大小约4MB。
- **时间开销**：每次内存访问需查询页表，增加延迟，尤其当页表存储在主存时。

为了解决这些问题，操作系统采用以下优化技术：
- **缓存（TLB）**：将常用页表项缓存到CPU内部的快速存储器。
- **间接方式**：使用多级页表或倒排页表减少页表空间占用。

## 4. TLB（转换旁路缓冲）
**TLB（Translation Lookaside Buffer）**是一种位于CPU内部的特殊高速缓存，用于存储最近使用的页表项，加速地址转换。

### 4.1 TLB的结构
TLB是一个小型、快速的关联存储器，表项包含：
- **页号**：逻辑页面的标识。
- **物理帧号**：对应的物理帧。
- **有效位**和**权限位**：与页表类似。
- **标签**：用于快速匹配页号。

TLB通常很小（几十到几百个表项），但访问速度极快（接近CPU寄存器）。

### 4.2 TLB的工作原理
1. CPU发出逻辑地址`(页号, 偏移量)`。
2. 检查TLB：
   - **TLB命中**：如果页号在TLB中，直接获取物理帧号，计算物理地址。
   - **TLB缺失**：查询内存中的页表，获取帧号并更新TLB。
3. 物理地址 = 帧号 × 页面大小 + 偏移量。

**例子**：
- 逻辑地址：`(页号=1, 偏移量=904)`，页面大小4KB。
- TLB内容：

| 页号 | 帧号 | 有效位 |
|------|------|--------|
| 0    | 10   | 1      |
| 1    | 15   | 1      |

- TLB命中：页号`1`对应帧`15`。
- 物理地址 = `15 × 4096 + 904 = 62344`。

### 4.3 TLB缺失的处理
当TLB中没有所需页表项时，发生**TLB缺失**，处理方式取决于CPU类型：
- **硬件处理**（常见于RISC架构，如ARM）：
  - 硬件自动查询内存中的页表，更新TLB。
  - 速度快，但硬件设计复杂。
- **软件处理**（常见于x86架构）：
  - 触发中断，操作系统查询页表并更新TLB。
  - 灵活但稍慢，依赖操作系统效率。

如果页表查询发现页面不在内存（有效位为0），触发**缺页中断**，操作系统从磁盘加载页面。

## 5. 间接方式：优化页表空间开销
为了减少页表的空间占用，操作系统使用以下间接方式：
- **多级页表**：
  - 将页表分为多级（如两级或三级），只为使用的页面分配页表。
  - 例子：32位系统，4KB页面，两级页表：
    - 第一级页表（页目录）索引1024个第二级页表。
    - 每个第二级页表索引1024个页面。
    - 未使用的页面无需分配页表，节省空间。
- **倒排页表**：
  - 按物理帧号索引，记录哪个进程的哪个页面占用该帧。
  - 适合物理内存较小的系统，但查询复杂。

**例子**（两级页表）：
- 逻辑地址：32位，页面大小4KB。
- 逻辑地址分为：10位一级页号、10位二级页号、12位偏移量。
- 第一级页表指向第二级页表的地址，第二级页表存储帧号。
- 优点：未使用的地址空间无需分配页表，节省内存。

## 6. 访问局部性与TLB优化
程序的内存访问通常具有**局部性**：
- **时间局部性**：最近访问的页面可能再次被访问。
- **空间局部性**：访问某页面后，可能访问其附近页面。

TLB利用局部性缓存常用页面映射，减少页表查询。编程时，应优化代码以增强局部性：
- **连续访问**：尽量访问连续的内存地址。
- **循环优化**：避免频繁跨页面访问。

**例子**：
```c
int array[1000];
// 优化：顺序访问
for (int i = 0; i < 1000; i++) {
    array[i] = 0; // 连续访问，空间局部性好
}
// 非优化：跳跃访问
for (int i = 0; i < 1000; i += 100) {
    array[i] = 0; // 跨页面访问，可能增加TLB缺失
}
```

## 7. 具体例子：分页与TLB应用
假设一个进程的逻辑地址空间为16KB，页面大小4KB（4页面），物理内存32KB（8帧）。页表如下：

| 页号 | 帧号 | 有效位 | 权限   |
|------|------|--------|--------|
| 0    | 2    | 1      | 读写   |
| 1    | 5    | 1      | 只读   |
| 2    | 7    | 1      | 读写   |
| 3    | -    | 0      | -      |

TLB内容：

| 页号 | 帧号 | 有效位 |
|------|------|--------|
| 0    | 2    | 1      |
| 1    | 5    | 1      |

**场景1**：访问逻辑地址`5000`（十六进制`0x1388`）：
- 页号 = `5000 ÷ 4096 = 1`，偏移量 = `5000 % 4096 = 904`。
- TLB命中：页号`1`对应帧`5`。
- 物理地址 = `5 × 4096 + 904 = 20480 + 904 = 21384`。

**场景2**：访问逻辑地址`12288`（十六进制`0x3000`）：
- 页号 = `12288 ÷ 4096 = 3`，偏移量 = `0`。
- TLB缺失：页号`3`不在TLB。
- 查询页表：页号`3`有效位为0，触发缺页中断。
- 操作系统从磁盘加载页面，更新页表和TLB。

**场景3**：尝试写入页号`1`：
- TLB命中：页号`1`对应帧`5`，但权限为“只读”。
- 触发访问错误，操作系统处理异常。

## 8. 页表与TLB的优缺点
### 8.1 页表的优缺点
- **优点**：
  - 支持虚拟内存，逻辑地址空间可大于物理内存。
  - 提供内存保护，防止非法访问。
  - 无外部碎片，内存分配简单。
- **缺点**：
  - 空间开销：页表可能占用大量内存。
  - 时间开销：页表查询增加访问延迟。

### 8.2 TLB的优缺点
- **优点**：
  - 加速地址转换，减少页表查询时间。
  - 利用程序局部性，命中率高。
- **缺点**：
  - TLB容量有限（几十到几百项），可能频繁缺失。
  - TLB缺失处理复杂，依赖硬件或操作系统。

## 9. 总结
页表是分页机制的核心，负责逻辑地址到物理地址的转换，但存在空间和时间开销。TLB通过缓存常用页表项显著提升性能，结合多级页表等间接方式进一步优化空间占用。关键点包括：
- **页表结构**：存储页号到帧号的映射，支持保护和虚拟内存。
- **TLB作用**：CPU内部的高速缓存，加速地址转换。
- **局部性优化**：编程时应增强访问局部性，减少TLB缺失。
- **地址转换**：通过页表和TLB将逻辑地址映射到物理地址。

对于初学者，理解页表和TLB的工作原理，以及通过具体例子（如地址转换和TLB命中/缺失）是掌握分页机制的关键。后续课程将深入探讨虚拟内存和缺页中断。