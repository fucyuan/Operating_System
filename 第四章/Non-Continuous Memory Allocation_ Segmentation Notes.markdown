# 非连续内存分配：分段

## 1. 背景：为什么需要非连续内存分配？
在操作系统中，内存管理是确保程序高效运行的核心任务。**连续内存分配**要求为程序分配一块连续的物理内存，但容易产生**外部碎片**（空闲内存块分散，无法分配给新程序）和**内部碎片**（分配的内存超出程序需求，造成浪费）。为了解决这些问题，操作系统引入了**非连续内存分配**，允许程序的内存分布在物理内存的非连续区域。

非连续内存分配的优点：
- **减少碎片**：灵活分配内存，降低外部碎片。
- **提高内存利用率**：程序可以利用分散的空闲内存块。
- **支持动态内存管理**：便于程序扩展或缩减内存需求。

两种主要的非连续内存分配方式：
- **分段（Segmentation）**：基于程序的逻辑结构分配内存。
- **分页（Paging）**：将内存分为固定大小的页面（将在后续笔记中讲解）。

本笔记重点讲解**分段**机制。

## 2. 分段的概念
分段是一种非连续内存分配方法，它根据程序的**逻辑结构**将程序划分为多个**段**（Segment），每个段是程序的一个逻辑单元，例如：
- 代码段（存储程序指令）
- 数据段（存储变量）
- 栈段（存储函数调用栈）
- 堆段（动态分配内存）

每个段可以独立分配到物理内存的任意位置，段内的地址是连续的，但不同段之间在物理内存中可以不连续。

### 2.1 分段的特点
- **逻辑划分**：段是程序的逻辑单元，符合程序员的开发思维。
- **灵活性**：段的大小可以不同，适合动态变化的内存需求。
- **保护与共享**：每个段可以设置独立的访问权限，便于内存保护和段共享。

## 3. 分段寻址机制
分段通过**逻辑地址**到**物理地址**的映射实现内存访问。逻辑地址由两部分组成：
- **段号（Segment Number）**：标识程序的某个段。
- **段内偏移量（Offset）**：表示段内相对于段起始地址的偏移。

### 3.1 逻辑地址的组成
逻辑地址可以表示为：`(段号, 偏移量)`。例如：
- 程序访问代码段的第100字节，逻辑地址可能是`(0, 100)`，其中`0`表示代码段。
- 访问数据段的第50字节，逻辑地址可能是`(1, 50)`，其中`1`表示数据段。

### 3.2 段表（Segment Table）
为了将逻辑地址映射到物理地址，操作系统维护一个**段表**，存储每个段的元信息。段表中的每条记录包含：
- **段起始地址**：该段在物理内存中的起始地址。
- **段长度**：该段的大小，用于检查偏移量是否合法。
- **访问权限**（可选）：如读、写、执行权限，用于内存保护。

段表存储在内存中，由操作系统管理，通常由硬件（如内存管理单元MMU）快速访问。

### 3.3 地址转换过程
将逻辑地址`(段号, 偏移量)`转换为物理地址的步骤：
1. **查找段表**：根据段号查找段表，获取段的起始地址和长度。
2. **检查偏移量**：确保偏移量小于段长度，否则触发内存访问错误（如“段错误”）。
3. **计算物理地址**：物理地址 = 段起始地址 + 偏移量。

**例子**：
假设段表如下：

| 段号 | 起始地址 | 段长度 |
|------|----------|--------|
| 0    | 1000     | 500    |
| 1    | 2000     | 300    |

逻辑地址为`(1, 50)`：
- 段号`1`对应段表中的起始地址`2000`，段长度`300`。
- 偏移量`50` < 段长度`300`，合法。
- 物理地址 = `2000 + 50 = 2050`。

## 4. 硬件支持下的分段寻址
分段机制依赖硬件支持，通常由**内存管理单元（MMU）**实现。MMU包含：
- **段表寄存器**：存储段表的基地址。
- **地址转换逻辑**：快速完成逻辑地址到物理地址的转换。

硬件支持的优点：
- **高效**：地址转换由硬件完成，速度快。
- **安全**：硬件检查偏移量和访问权限，防止非法内存访问。

**工作流程**：
1. CPU发出逻辑地址`(段号, 偏移量)`。
2. MMU根据段号查询段表，获取段信息。
3. MMU验证偏移量合法性。
4. MMU计算物理地址并访问内存。

## 5. 分段管理的优缺点
### 5.1 优点
- **逻辑清晰**：段基于程序的逻辑结构，便于开发和调试。
- **灵活分配**：段大小可变，适合动态内存需求。
- **内存保护**：每个段可设置独立权限，防止非法访问。
- **内存共享**：多个程序可共享同一段（如共享库）。

### 5.2 缺点
- **外部碎片**：段大小不固定，可能导致物理内存中分散的空闲块无法利用。
- **管理复杂**：段表维护和地址转换需要额外开销。
- **硬件依赖**：需要MMU等硬件支持。

## 6. 具体例子：分段在实际程序中的应用
假设一个简单的程序包含以下段：
- **代码段**（段号0）：存储程序指令，大小400字节。
- **数据段**（段号1）：存储全局变量，大小200字节。
- **栈段**（段号2）：存储函数调用栈，大小300字节。

操作系统为该程序分配内存，段表如下：

| 段号 | 起始地址 | 段长度 | 权限   |
|------|----------|--------|--------|
| 0    | 1000     | 400    | 只读   |
| 1    | 1500     | 200    | 读写   |
| 2    | 2000     | 300    | 读写   |

**场景1**：程序访问逻辑地址`(0, 100)`（代码段的第100字节）：
- 段号`0`：起始地址`1000`，长度`400`。
- 偏移量`100` < `400`，合法。
- 物理地址 = `1000 + 100 = 1100`。

**场景2**：程序访问逻辑地址`(1, 250)`（数据段的第250字节）：
- 段号`1`：起始地址`1500`，长度`200`。
- 偏移量`250` > `200`，非法，触发“段错误”。

**场景3**：程序尝试写入代码段`(0, 50)`：
- 段号`0`的权限为“只读”，写入操作被硬件阻止，触发访问错误。

## 7. 分段与分页的区别（简单对比）
虽然本笔记聚焦分段，但了解分段与分页的区别有助于理解非连续内存分配：
- **分段**：
  - 基于程序的逻辑结构，段大小可变。
  - 逻辑地址：`(段号, 偏移量)`。
  - 优点：逻辑清晰，适合保护和共享。
  - 缺点：可能产生外部碎片。
- **分页**：
  - 将内存分为固定大小的页面（Page），通常为4KB。
  - 逻辑地址：`(页面号, 页面偏移)`。
  - 优点：无外部碎片，管理简单。
  - 缺点：可能产生内部碎片，逻辑结构不直观。

## 8. 总结
分段是一种非连续内存分配方法，通过将程序划分为逻辑段（如代码段、数据段）实现灵活的内存管理。核心机制包括：
- **逻辑地址**：由段号和偏移量组成。
- **段表**：存储段的起始地址、长度和权限信息。
- **地址转换**：通过段表和硬件支持（如MMU）将逻辑地址映射到物理地址。

分段的优点是逻辑清晰、支持保护和共享，但可能产生外部碎片。理解分段机制是掌握操作系统内存管理的基础，对于初学者来说，通过具体例子（如段表和地址转换）可以更直观地理解其工作原理。